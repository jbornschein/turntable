
foodloader:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000360  00001c00  00001c00  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00001f60  000003f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000006  00800066  00800066  000003fa  2**0
                  ALLOC
  3 .stab         000012f0  00000000  00000000  000003fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000bac  00000000  00000000  000016ec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001c00 <__vectors>:
    1c00:	12 c0       	rjmp	.+36     	; 0x1c26 <__ctors_end>
    1c02:	2c c0       	rjmp	.+88     	; 0x1c5c <__bad_interrupt>
    1c04:	2b c0       	rjmp	.+86     	; 0x1c5c <__bad_interrupt>
    1c06:	2a c0       	rjmp	.+84     	; 0x1c5c <__bad_interrupt>
    1c08:	29 c0       	rjmp	.+82     	; 0x1c5c <__bad_interrupt>
    1c0a:	28 c0       	rjmp	.+80     	; 0x1c5c <__bad_interrupt>
    1c0c:	27 c0       	rjmp	.+78     	; 0x1c5c <__bad_interrupt>
    1c0e:	26 c0       	rjmp	.+76     	; 0x1c5c <__bad_interrupt>
    1c10:	25 c0       	rjmp	.+74     	; 0x1c5c <__bad_interrupt>
    1c12:	24 c0       	rjmp	.+72     	; 0x1c5c <__bad_interrupt>
    1c14:	23 c0       	rjmp	.+70     	; 0x1c5c <__bad_interrupt>
    1c16:	22 c0       	rjmp	.+68     	; 0x1c5c <__bad_interrupt>
    1c18:	21 c0       	rjmp	.+66     	; 0x1c5c <__bad_interrupt>
    1c1a:	20 c0       	rjmp	.+64     	; 0x1c5c <__bad_interrupt>
    1c1c:	1f c0       	rjmp	.+62     	; 0x1c5c <__bad_interrupt>
    1c1e:	1e c0       	rjmp	.+60     	; 0x1c5c <__bad_interrupt>
    1c20:	1d c0       	rjmp	.+58     	; 0x1c5c <__bad_interrupt>
    1c22:	1c c0       	rjmp	.+56     	; 0x1c5c <__bad_interrupt>
    1c24:	1b c0       	rjmp	.+54     	; 0x1c5c <__bad_interrupt>

00001c26 <__ctors_end>:
    1c26:	11 24       	eor	r1, r1
    1c28:	1f be       	out	0x3f, r1	; 63
    1c2a:	cf e5       	ldi	r28, 0x5F	; 95
    1c2c:	d4 e0       	ldi	r29, 0x04	; 4
    1c2e:	de bf       	out	0x3e, r29	; 62
    1c30:	cd bf       	out	0x3d, r28	; 61

00001c32 <__do_copy_data>:
    1c32:	10 e0       	ldi	r17, 0x00	; 0
    1c34:	a0 e6       	ldi	r26, 0x60	; 96
    1c36:	b0 e0       	ldi	r27, 0x00	; 0
    1c38:	e0 e6       	ldi	r30, 0x60	; 96
    1c3a:	ff e1       	ldi	r31, 0x1F	; 31
    1c3c:	02 c0       	rjmp	.+4      	; 0x1c42 <.do_copy_data_start>

00001c3e <.do_copy_data_loop>:
    1c3e:	05 90       	lpm	r0, Z+
    1c40:	0d 92       	st	X+, r0

00001c42 <.do_copy_data_start>:
    1c42:	a6 36       	cpi	r26, 0x66	; 102
    1c44:	b1 07       	cpc	r27, r17
    1c46:	d9 f7       	brne	.-10     	; 0x1c3e <.do_copy_data_loop>

00001c48 <__do_clear_bss>:
    1c48:	10 e0       	ldi	r17, 0x00	; 0
    1c4a:	a6 e6       	ldi	r26, 0x66	; 102
    1c4c:	b0 e0       	ldi	r27, 0x00	; 0
    1c4e:	01 c0       	rjmp	.+2      	; 0x1c52 <.do_clear_bss_start>

00001c50 <.do_clear_bss_loop>:
    1c50:	1d 92       	st	X+, r1

00001c52 <.do_clear_bss_start>:
    1c52:	ac 36       	cpi	r26, 0x6C	; 108
    1c54:	b1 07       	cpc	r27, r17
    1c56:	e1 f7       	brne	.-8      	; 0x1c50 <.do_clear_bss_loop>
    1c58:	10 d0       	rcall	.+32     	; 0x1c7a <main>
    1c5a:	80 c1       	rjmp	.+768    	; 0x1f5c <_exit>

00001c5c <__bad_interrupt>:
    1c5c:	d1 cf       	rjmp	.-94     	; 0x1c00 <__vectors>

00001c5e <uart_putc>:
/** output one character */
static noinline void uart_putc(uint8_t data)
/*{{{*/ {

    /* loop until data has been transmitted */
    while (!(_UCSRA_UART0 & _BV(_UDRE_UART0)));
    1c5e:	5d 9b       	sbis	0x0b, 5	; 11
    1c60:	fe cf       	rjmp	.-4      	; 0x1c5e <uart_putc>

    /* put data in buffer */
    _UDR_UART0 = data;
    1c62:	8c b9       	out	0x0c, r24	; 12

} /* }}} */
    1c64:	08 95       	ret

00001c66 <uart_getc>:
/** block until one character has been read */
static noinline uint8_t uart_getc(void)
/*{{{*/ {

    /* wait if a byte has been received */
    while (!(_UCSRA_UART0 & _BV(_RXC_UART0)));
    1c66:	5f 9b       	sbis	0x0b, 7	; 11
    1c68:	fe cf       	rjmp	.-4      	; 0x1c66 <uart_getc>

    /* return received byte */
    return _UDR_UART0;
    1c6a:	8c b1       	in	r24, 0x0c	; 12

} /* }}} */
    1c6c:	08 95       	ret

00001c6e <start_application>:
#   	endif

        /* move interrupt vectors to application section and jump to main program */
//        _IVREG = _BV(IVCE);
//        _IVREG = 0;
        jump_to_application();
    1c6e:	e0 91 66 00 	lds	r30, 0x0066
    1c72:	f0 91 67 00 	lds	r31, 0x0067
    1c76:	09 95       	icall

} /* }}} */
    1c78:	08 95       	ret

00001c7a <main>:

int main(void)
/* {{{ */ {
    1c7a:	4f 92       	push	r4
    1c7c:	5f 92       	push	r5
    1c7e:	6f 92       	push	r6
    1c80:	7f 92       	push	r7
    1c82:	8f 92       	push	r8
    1c84:	9f 92       	push	r9
    1c86:	af 92       	push	r10
    1c88:	bf 92       	push	r11
    1c8a:	cf 92       	push	r12
    1c8c:	df 92       	push	r13
    1c8e:	ef 92       	push	r14
    1c90:	ff 92       	push	r15
    1c92:	0f 93       	push	r16
    1c94:	1f 93       	push	r17
    1c96:	cf 93       	push	r28
    1c98:	df 93       	push	r29
/** init the hardware uart */
static inline void init_uart(void)
/*{{{*/ {

    /* set baud rate */
    _UBRRH_UART0 = (uint8_t)(UART_UBRR >> 8);  /* high byte */
    1c9a:	10 bc       	out	0x20, r1	; 32
    _UBRRL_UART0 = (uint8_t)UART_UBRR;         /* low byte */
    1c9c:	88 e0       	ldi	r24, 0x08	; 8
    1c9e:	89 b9       	out	0x09, r24	; 9

    /* set mode */
    _UCSRC_UART0 = UART_UCSRC;
    1ca0:	86 e8       	ldi	r24, 0x86	; 134
    1ca2:	80 bd       	out	0x20, r24	; 32

    /* enable transmitter, receiver */
    _UCSRB_UART0 = _BV(_TXEN_UART0) | _BV(_RXEN_UART0);
    1ca4:	88 e1       	ldi	r24, 0x18	; 24
    1ca6:	8a b9       	out	0x0a, r24	; 10

    init_uart();

    /* send boot message */
#   if SEND_BOOT_MESSAGE
        uart_putc('b');
    1ca8:	82 e6       	ldi	r24, 0x62	; 98
    1caa:	d9 df       	rcall	.-78     	; 0x1c5e <uart_putc>
    1cac:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1cae:	40 e5       	ldi	r20, 0x50	; 80
    1cb0:	53 ec       	ldi	r21, 0xC3	; 195
    1cb2:	ca 01       	movw	r24, r20
    1cb4:	01 97       	sbiw	r24, 0x01	; 1
    1cb6:	f1 f7       	brne	.-4      	; 0x1cb4 <main+0x3a>
    uint8_t i;

    for(i = 0; i < 10; i++) {
        _delay_loop_2(50000);

        if(_UCSRA_UART0 & _BV(_RXC_UART0)) {
    1cb8:	5f 9b       	sbis	0x0b, 7	; 11
    1cba:	03 c0       	rjmp	.+6      	; 0x1cc2 <main+0x48>
            if(_UDR_UART0 == BOOTLOADER_ENTRY_CHAR) {
    1cbc:	8c b1       	in	r24, 0x0c	; 12
    1cbe:	80 37       	cpi	r24, 0x70	; 112
    1cc0:	21 f0       	breq	.+8      	; 0x1cca <main+0x50>
/* loop a few times, and see if the character is received */
static inline uint8_t wait_for_char(void)
/*{{{*/ {
    uint8_t i;

    for(i = 0; i < 10; i++) {
    1cc2:	2f 5f       	subi	r18, 0xFF	; 255
    1cc4:	2a 30       	cpi	r18, 0x0A	; 10
    1cc6:	a9 f7       	brne	.-22     	; 0x1cb2 <main+0x38>
    1cc8:	30 c1       	rjmp	.+608    	; 0x1f2a <main+0x2b0>

	
//start_bootloader:
	
#   if SEND_BOOT_MESSAGE
    uart_putc('p');
    1cca:	80 e7       	ldi	r24, 0x70	; 112
    1ccc:	c8 df       	rcall	.-112    	; 0x1c5e <uart_putc>

                        /* iterate over all pages in flash, and try to erase every single
                         * one of them (the bootloader section should be protected by lock-bits (!) */

                        for (flash_address = 0; flash_address < BOOT_SECTION_START; flash_address += SPM_PAGESIZE) {
                            boot_page_erase_safe(flash_address);
    1cce:	63 e0       	ldi	r22, 0x03	; 3
    1cd0:	76 2e       	mov	r7, r22

                                /* get data word */
                                temp_word_buffer = uart_getc() | (uart_getc() << 8);

                                /* write data to temporary buffer */
                                boot_page_fill(temp_address, temp_word_buffer);
    1cd2:	66 24       	eor	r6, r6
    1cd4:	63 94       	inc	r6
                                 * address, but we are writing words! */
                                temp_address += 2;
                            }

                            /* after filling the temp buffer, write the page and wait till we're done */
                            boot_page_write_safe(flash_address);
    1cd6:	55 e0       	ldi	r21, 0x05	; 5
    1cd8:	55 2e       	mov	r5, r21
                            boot_spm_busy_wait();

                            /* re-enable application flash section, so we can read it again */
                            boot_rww_enable();
    1cda:	41 e1       	ldi	r20, 0x11	; 17
    1cdc:	44 2e       	mov	r4, r20
    while (1)
    {
        uint8_t command;

        /* block until a command has been received */
        command = uart_getc();
    1cde:	c3 df       	rcall	.-122    	; 0x1c66 <uart_getc>

        switch (command)
    1ce0:	86 35       	cpi	r24, 0x56	; 86
    1ce2:	09 f4       	brne	.+2      	; 0x1ce6 <main+0x6c>
    1ce4:	72 c0       	rjmp	.+228    	; 0x1dca <main+0x150>
    1ce6:	87 35       	cpi	r24, 0x57	; 87
    1ce8:	c8 f4       	brcc	.+50     	; 0x1d1c <main+0xa2>
    1cea:	8c 34       	cpi	r24, 0x4C	; 76
    1cec:	09 f4       	brne	.+2      	; 0x1cf0 <main+0x76>
    1cee:	e1 c0       	rjmp	.+450    	; 0x1eb2 <main+0x238>
    1cf0:	8d 34       	cpi	r24, 0x4D	; 77
    1cf2:	50 f4       	brcc	.+20     	; 0x1d08 <main+0x8e>
    1cf4:	82 34       	cpi	r24, 0x42	; 66
    1cf6:	09 f4       	brne	.+2      	; 0x1cfa <main+0x80>
    1cf8:	76 c0       	rjmp	.+236    	; 0x1de6 <main+0x16c>
    1cfa:	85 34       	cpi	r24, 0x45	; 69
    1cfc:	09 f4       	brne	.+2      	; 0x1d00 <main+0x86>
    1cfe:	d9 c0       	rjmp	.+434    	; 0x1eb2 <main+0x238>
    1d00:	81 34       	cpi	r24, 0x41	; 65
    1d02:	09 f0       	breq	.+2      	; 0x1d06 <main+0x8c>
    1d04:	0f c1       	rjmp	.+542    	; 0x1f24 <main+0x2aa>
    1d06:	28 c0       	rjmp	.+80     	; 0x1d58 <main+0xde>
    1d08:	83 35       	cpi	r24, 0x53	; 83
    1d0a:	09 f4       	brne	.+2      	; 0x1d0e <main+0x94>
    1d0c:	56 c0       	rjmp	.+172    	; 0x1dba <main+0x140>
    1d0e:	84 35       	cpi	r24, 0x54	; 84
    1d10:	09 f4       	brne	.+2      	; 0x1d14 <main+0x9a>
    1d12:	47 c0       	rjmp	.+142    	; 0x1da2 <main+0x128>
    1d14:	80 35       	cpi	r24, 0x50	; 80
    1d16:	09 f0       	breq	.+2      	; 0x1d1a <main+0xa0>
    1d18:	05 c1       	rjmp	.+522    	; 0x1f24 <main+0x2aa>
    1d1a:	cb c0       	rjmp	.+406    	; 0x1eb2 <main+0x238>
    1d1c:	85 36       	cpi	r24, 0x65	; 101
    1d1e:	59 f1       	breq	.+86     	; 0x1d76 <main+0xfc>
    1d20:	86 36       	cpi	r24, 0x66	; 102
    1d22:	48 f4       	brcc	.+18     	; 0x1d36 <main+0xbc>
    1d24:	81 36       	cpi	r24, 0x61	; 97
    1d26:	b1 f0       	breq	.+44     	; 0x1d54 <main+0xda>
    1d28:	82 36       	cpi	r24, 0x62	; 98
    1d2a:	09 f4       	brne	.+2      	; 0x1d2e <main+0xb4>
    1d2c:	56 c0       	rjmp	.+172    	; 0x1dda <main+0x160>
    1d2e:	88 35       	cpi	r24, 0x58	; 88
    1d30:	09 f0       	breq	.+2      	; 0x1d34 <main+0xba>
    1d32:	f8 c0       	rjmp	.+496    	; 0x1f24 <main+0x2aa>
    1d34:	50 c0       	rjmp	.+160    	; 0x1dd6 <main+0x15c>
    1d36:	80 37       	cpi	r24, 0x70	; 112
    1d38:	09 f4       	brne	.+2      	; 0x1d3c <main+0xc2>
    1d3a:	4b c0       	rjmp	.+150    	; 0x1dd2 <main+0x158>
    1d3c:	81 37       	cpi	r24, 0x71	; 113
    1d3e:	20 f4       	brcc	.+8      	; 0x1d48 <main+0xce>
    1d40:	87 36       	cpi	r24, 0x67	; 103
    1d42:	09 f0       	breq	.+2      	; 0x1d46 <main+0xcc>
    1d44:	ef c0       	rjmp	.+478    	; 0x1f24 <main+0x2aa>
    1d46:	b7 c0       	rjmp	.+366    	; 0x1eb6 <main+0x23c>
    1d48:	83 37       	cpi	r24, 0x73	; 115
    1d4a:	69 f1       	breq	.+90     	; 0x1da6 <main+0x12c>
    1d4c:	84 37       	cpi	r24, 0x74	; 116
    1d4e:	09 f0       	breq	.+2      	; 0x1d52 <main+0xd8>
    1d50:	e9 c0       	rjmp	.+466    	; 0x1f24 <main+0x2aa>
    1d52:	2f c0       	rjmp	.+94     	; 0x1db2 <main+0x138>
#endif
                        uart_putc('\r');
                        break;

            case 'a':   /* report if we support address autoincrementing: yes, of course */
                        uart_putc('Y');
    1d54:	89 e5       	ldi	r24, 0x59	; 89
    1d56:	e7 c0       	rjmp	.+462    	; 0x1f26 <main+0x2ac>

            case 'A':   /* set write address start (in words), read high and low byte and respond with CR */
                        /* {{{ */

                        /* eeprom address is a byte address */
                        eeprom_address = (uart_getc() << 8) | uart_getc();
    1d58:	86 df       	rcall	.-244    	; 0x1c66 <uart_getc>
    1d5a:	18 2f       	mov	r17, r24
    1d5c:	84 df       	rcall	.-248    	; 0x1c66 <uart_getc>
    1d5e:	b1 2e       	mov	r11, r17
    1d60:	aa 24       	eor	r10, r10
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	8a 29       	or	r24, r10
    1d66:	9b 29       	or	r25, r11
    1d68:	90 93 69 00 	sts	0x0069, r25
    1d6c:	80 93 68 00 	sts	0x0068, r24

                        /* flash address is a byte address too, but we get a
                         * word address so convert it */
                        flash_address = eeprom_address;
                        flash_address <<= 1;
    1d70:	88 0f       	add	r24, r24
    1d72:	99 1f       	adc	r25, r25
    1d74:	81 c0       	rjmp	.+258    	; 0x1e78 <main+0x1fe>

                        /* acknowledge */
                        uart_putc('\r');
                        break;
    1d76:	e0 e0       	ldi	r30, 0x00	; 0
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	0a c0       	rjmp	.+20     	; 0x1d90 <main+0x116>

                        /* iterate over all pages in flash, and try to erase every single
                         * one of them (the bootloader section should be protected by lock-bits (!) */

                        for (flash_address = 0; flash_address < BOOT_SECTION_START; flash_address += SPM_PAGESIZE) {
                            boot_page_erase_safe(flash_address);
    1d7c:	07 b6       	in	r0, 0x37	; 55
    1d7e:	00 fc       	sbrc	r0, 0
    1d80:	fd cf       	rjmp	.-6      	; 0x1d7c <main+0x102>
    1d82:	e1 99       	sbic	0x1c, 1	; 28
    1d84:	fe cf       	rjmp	.-4      	; 0x1d82 <main+0x108>
    1d86:	70 92 57 00 	sts	0x0057, r7
    1d8a:	e8 95       	spm
    1d8c:	e0 5c       	subi	r30, 0xC0	; 192
    1d8e:	ff 4f       	sbci	r31, 0xFF	; 255
                        /* {{{ */

                        /* iterate over all pages in flash, and try to erase every single
                         * one of them (the bootloader section should be protected by lock-bits (!) */

                        for (flash_address = 0; flash_address < BOOT_SECTION_START; flash_address += SPM_PAGESIZE) {
    1d90:	2c e1       	ldi	r18, 0x1C	; 28
    1d92:	e0 30       	cpi	r30, 0x00	; 0
    1d94:	f2 07       	cpc	r31, r18
    1d96:	90 f3       	brcs	.-28     	; 0x1d7c <main+0x102>
    1d98:	f0 93 6b 00 	sts	0x006B, r31
    1d9c:	e0 93 6a 00 	sts	0x006A, r30
    1da0:	88 c0       	rjmp	.+272    	; 0x1eb2 <main+0x238>
            case 'T':   /* select device type: received device type and respond with CR */
                        /* ignore this command, only the device this bootloader
                         * is installed on can be programmed :) */

                        /* discard byte and acknowledge */
                        uart_getc();
    1da2:	61 df       	rcall	.-318    	; 0x1c66 <uart_getc>
    1da4:	86 c0       	rjmp	.+268    	; 0x1eb2 <main+0x238>
                        uart_putc('\r');
                        break;

            case 's':   /* read signature bytes: respond with the three signature bytes for this MCU */
                        uart_putc(_SIG_BYTE_3);
    1da6:	87 e0       	ldi	r24, 0x07	; 7
    1da8:	5a df       	rcall	.-332    	; 0x1c5e <uart_putc>
                        uart_putc(_SIG_BYTE_2);
    1daa:	83 e9       	ldi	r24, 0x93	; 147
    1dac:	58 df       	rcall	.-336    	; 0x1c5e <uart_putc>
                        uart_putc(_SIG_BYTE_1);
    1dae:	8e e1       	ldi	r24, 0x1E	; 30
    1db0:	ba c0       	rjmp	.+372    	; 0x1f26 <main+0x2ac>
                        break;

            case 't':   /* return supported device codes (only one in this case), and terminate with a nullbyte */
                        uart_putc(_AVR910_DEVCODE);
    1db2:	86 e7       	ldi	r24, 0x76	; 118
    1db4:	54 df       	rcall	.-344    	; 0x1c5e <uart_putc>
                        uart_putc(0);
    1db6:	80 e0       	ldi	r24, 0x00	; 0
    1db8:	b6 c0       	rjmp	.+364    	; 0x1f26 <main+0x2ac>
                        break;

            case 'S':   /* give software identifier, send exactly 7 chars */
                        uart_puts((uint8_t *)"FDL v");
    1dba:	c0 e6       	ldi	r28, 0x60	; 96
    1dbc:	d0 e0       	ldi	r29, 0x00	; 0
    1dbe:	02 c0       	rjmp	.+4      	; 0x1dc4 <main+0x14a>
static inline void uart_puts(uint8_t buffer[])
/*{{{*/ {

    /* send everything until end of string */
    while (*buffer != 0) {
        uart_putc(*buffer);
    1dc0:	4e df       	rcall	.-356    	; 0x1c5e <uart_putc>
        buffer++;
    1dc2:	21 96       	adiw	r28, 0x01	; 1
/** output a string */
static inline void uart_puts(uint8_t buffer[])
/*{{{*/ {

    /* send everything until end of string */
    while (*buffer != 0) {
    1dc4:	88 81       	ld	r24, Y
    1dc6:	88 23       	and	r24, r24
    1dc8:	d9 f7       	brne	.-10     	; 0x1dc0 <main+0x146>

            case 'S':   /* give software identifier, send exactly 7 chars */
                        uart_puts((uint8_t *)"FDL v");

            case 'V':   /* return software version (2 byte) */
                        uart_putc(VERSION_BYTE_1);
    1dca:	80 e3       	ldi	r24, 0x30	; 48
    1dcc:	48 df       	rcall	.-368    	; 0x1c5e <uart_putc>
                        uart_putc(VERSION_BYTE_2);
    1dce:	82 e3       	ldi	r24, 0x32	; 50
    1dd0:	aa c0       	rjmp	.+340    	; 0x1f26 <main+0x2ac>
                        break;

            case 'p':   /* send programmer type, in this case 'S' for serial */
                        uart_putc('S');
    1dd2:	83 e5       	ldi	r24, 0x53	; 83
    1dd4:	a8 c0       	rjmp	.+336    	; 0x1f26 <main+0x2ac>
#if EXIT_BOOTLOADER == 1
            case 'E':   /* exit bootloader */
#endif
            case 'X':   /* start application */

                        start_application();
    1dd6:	4b df       	rcall	.-362    	; 0x1c6e <start_application>
    1dd8:	6c c0       	rjmp	.+216    	; 0x1eb2 <main+0x238>
                        uart_putc('\r');

                        break;

            case 'b':   /* check block support: return yes and 2 bytes block size we support */
                        uart_putc('Y');
    1dda:	89 e5       	ldi	r24, 0x59	; 89
    1ddc:	40 df       	rcall	.-384    	; 0x1c5e <uart_putc>
                        uart_putc(HIGH(BLOCKSIZE));
    1dde:	80 e0       	ldi	r24, 0x00	; 0
    1de0:	3e df       	rcall	.-388    	; 0x1c5e <uart_putc>
                        uart_putc(LOW(BLOCKSIZE));
    1de2:	80 e4       	ldi	r24, 0x40	; 64
    1de4:	a0 c0       	rjmp	.+320    	; 0x1f26 <main+0x2ac>

            case 'B':   /* start block flash or eeprom load (fill mcu internal page buffer) */
                        /* {{{ */

                        /* first, read buffer size (in bytes) */
                        buffer_size = (uart_getc() << 8) | uart_getc();
    1de6:	3f df       	rcall	.-386    	; 0x1c66 <uart_getc>
    1de8:	3e df       	rcall	.-388    	; 0x1c66 <uart_getc>
    1dea:	08 2f       	mov	r16, r24

                        /* check if our buffer can hold all this data */
                        if (buffer_size > BLOCKSIZE) {
    1dec:	81 34       	cpi	r24, 0x41	; 65
    1dee:	08 f0       	brcs	.+2      	; 0x1df2 <main+0x178>
    1df0:	99 c0       	rjmp	.+306    	; 0x1f24 <main+0x2aa>
                            uart_putc('?');
                            break;
                        }

                        /* then, read flash ('F') or eeprom ('E') memory type */
                        memory_type = uart_getc();
    1df2:	39 df       	rcall	.-398    	; 0x1c66 <uart_getc>

                        /* memory type is flash */
                        if (memory_type == 'F')
    1df4:	86 34       	cpi	r24, 0x46	; 70
    1df6:	09 f0       	breq	.+2      	; 0x1dfa <main+0x180>
    1df8:	44 c0       	rjmp	.+136    	; 0x1e82 <main+0x208>
                        /* {{{ */ {

                            BUF_T i;
                            uint16_t temp_word_buffer;

                            if (flash_address > BOOT_SECTION_START) {
    1dfa:	80 91 6a 00 	lds	r24, 0x006A
    1dfe:	90 91 6b 00 	lds	r25, 0x006B
    1e02:	81 50       	subi	r24, 0x01	; 1
    1e04:	9c 41       	sbci	r25, 0x1C	; 28
    1e06:	10 f0       	brcs	.+4      	; 0x1e0c <main+0x192>
                                uart_putc(0);
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	29 df       	rcall	.-430    	; 0x1c5e <uart_putc>
                            }

							#ifdef FLASH_G_64K
                            uint32_t temp_address = flash_address;
                            #else
                            uint16_t temp_address = flash_address;
    1e0c:	c0 90 6a 00 	lds	r12, 0x006A
    1e10:	d0 90 6b 00 	lds	r13, 0x006B
                            #endif
							
                            boot_spm_busy_wait();
    1e14:	07 b6       	in	r0, 0x37	; 55
    1e16:	00 fc       	sbrc	r0, 0
    1e18:	fd cf       	rjmp	.-6      	; 0x1e14 <main+0x19a>

                            /* read data, wordwise, low byte first */
                            for (i = 0; i < buffer_size/2; i++) {
    1e1a:	e0 2e       	mov	r14, r16
    1e1c:	e6 94       	lsr	r14
    1e1e:	e6 01       	movw	r28, r12
    1e20:	ff 24       	eor	r15, r15
    1e22:	10 c0       	rjmp	.+32     	; 0x1e44 <main+0x1ca>

                                /* get data word */
                                temp_word_buffer = uart_getc() | (uart_getc() << 8);
    1e24:	20 df       	rcall	.-448    	; 0x1c66 <uart_getc>
    1e26:	08 2f       	mov	r16, r24
    1e28:	1e df       	rcall	.-452    	; 0x1c66 <uart_getc>

                                /* write data to temporary buffer */
                                boot_page_fill(temp_address, temp_word_buffer);
    1e2a:	98 2e       	mov	r9, r24
    1e2c:	88 24       	eor	r8, r8
    1e2e:	10 e0       	ldi	r17, 0x00	; 0
    1e30:	08 29       	or	r16, r8
    1e32:	19 29       	or	r17, r9
    1e34:	fe 01       	movw	r30, r28
    1e36:	08 01       	movw	r0, r16
    1e38:	60 92 57 00 	sts	0x0057, r6
    1e3c:	e8 95       	spm
    1e3e:	11 24       	eor	r1, r1

                                /* increment by two, since temp_address is a byte
                                 * address, but we are writing words! */
                                temp_address += 2;
    1e40:	22 96       	adiw	r28, 0x02	; 2
                            #endif
							
                            boot_spm_busy_wait();

                            /* read data, wordwise, low byte first */
                            for (i = 0; i < buffer_size/2; i++) {
    1e42:	f3 94       	inc	r15
    1e44:	fe 14       	cp	r15, r14
    1e46:	70 f3       	brcs	.-36     	; 0x1e24 <main+0x1aa>
    1e48:	8e 2d       	mov	r24, r14
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	88 0f       	add	r24, r24
    1e4e:	99 1f       	adc	r25, r25
    1e50:	8c 0d       	add	r24, r12
    1e52:	9d 1d       	adc	r25, r13
                                 * address, but we are writing words! */
                                temp_address += 2;
                            }

                            /* after filling the temp buffer, write the page and wait till we're done */
                            boot_page_write_safe(flash_address);
    1e54:	07 b6       	in	r0, 0x37	; 55
    1e56:	00 fc       	sbrc	r0, 0
    1e58:	fd cf       	rjmp	.-6      	; 0x1e54 <main+0x1da>
    1e5a:	e1 99       	sbic	0x1c, 1	; 28
    1e5c:	fe cf       	rjmp	.-4      	; 0x1e5a <main+0x1e0>
    1e5e:	e0 91 6a 00 	lds	r30, 0x006A
    1e62:	f0 91 6b 00 	lds	r31, 0x006B
    1e66:	50 92 57 00 	sts	0x0057, r5
    1e6a:	e8 95       	spm
                            boot_spm_busy_wait();
    1e6c:	07 b6       	in	r0, 0x37	; 55
    1e6e:	00 fc       	sbrc	r0, 0
    1e70:	fd cf       	rjmp	.-6      	; 0x1e6c <main+0x1f2>

                            /* re-enable application flash section, so we can read it again */
                            boot_rww_enable();
    1e72:	40 92 57 00 	sts	0x0057, r4
    1e76:	e8 95       	spm

                            /* store next page's address, since we do auto-address-incrementing */
                            flash_address = temp_address;
    1e78:	90 93 6b 00 	sts	0x006B, r25
    1e7c:	80 93 6a 00 	sts	0x006A, r24
    1e80:	18 c0       	rjmp	.+48     	; 0x1eb2 <main+0x238>

                            uart_putc('\r');

                        } /* }}} */
                        else if (memory_type == 'E')
    1e82:	85 34       	cpi	r24, 0x45	; 69
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <main+0x20e>
    1e86:	4e c0       	rjmp	.+156    	; 0x1f24 <main+0x2aa>
    1e88:	10 e0       	ldi	r17, 0x00	; 0
    1e8a:	11 c0       	rjmp	.+34     	; 0x1eae <main+0x234>
                            //uart_putc('E');
                            uint8_t temp_data;
                            BUF_T i;

                            for (i = 0; i < buffer_size; i++) {
                                temp_data = uart_getc();
    1e8c:	ec de       	rcall	.-552    	; 0x1c66 <uart_getc>
    1e8e:	68 2f       	mov	r22, r24
                                eeprom_write_byte( (uint8_t *)eeprom_address, temp_data);
    1e90:	80 91 68 00 	lds	r24, 0x0068
    1e94:	90 91 69 00 	lds	r25, 0x0069
    1e98:	54 d0       	rcall	.+168    	; 0x1f42 <__eewr_byte_m8>

                                eeprom_address++;
    1e9a:	80 91 68 00 	lds	r24, 0x0068
    1e9e:	90 91 69 00 	lds	r25, 0x0069
    1ea2:	01 96       	adiw	r24, 0x01	; 1
    1ea4:	90 93 69 00 	sts	0x0069, r25
    1ea8:	80 93 68 00 	sts	0x0068, r24

                            //uart_putc('E');
                            uint8_t temp_data;
                            BUF_T i;

                            for (i = 0; i < buffer_size; i++) {
    1eac:	1f 5f       	subi	r17, 0xFF	; 255
    1eae:	10 17       	cp	r17, r16
    1eb0:	68 f3       	brcs	.-38     	; 0x1e8c <main+0x212>
                                eeprom_write_byte( (uint8_t *)eeprom_address, temp_data);

                                eeprom_address++;
                            }

                            uart_putc('\r');
    1eb2:	8d e0       	ldi	r24, 0x0D	; 13
    1eb4:	38 c0       	rjmp	.+112    	; 0x1f26 <main+0x2ac>

            case 'g':   /* start block flash or eeprom read */
                        /* {{{ */

                        /* first, read byte counter */
                        buffer_size = (uart_getc() << 8) | uart_getc();
    1eb6:	d7 de       	rcall	.-594    	; 0x1c66 <uart_getc>
    1eb8:	d6 de       	rcall	.-596    	; 0x1c66 <uart_getc>
    1eba:	e8 2e       	mov	r14, r24

                        /* then, read memory type */
                        memory_type = uart_getc();
    1ebc:	d4 de       	rcall	.-600    	; 0x1c66 <uart_getc>

                        /* memory type is flash */
                        if (memory_type == 'F')
    1ebe:	86 34       	cpi	r24, 0x46	; 70
    1ec0:	d1 f4       	brne	.+52     	; 0x1ef6 <main+0x27c>
    1ec2:	ff 24       	eor	r15, r15
    1ec4:	15 c0       	rjmp	.+42     	; 0x1ef0 <main+0x276>

                                /* read word */
								#ifdef FLASH_G_64K
								temp_word_buffer = pgm_read_word_far(flash_address);
								#else
                                temp_word_buffer = pgm_read_word(flash_address);
    1ec6:	e0 91 6a 00 	lds	r30, 0x006A
    1eca:	f0 91 6b 00 	lds	r31, 0x006B
    1ece:	05 91       	lpm	r16, Z+
    1ed0:	14 91       	lpm	r17, Z+
								#endif
								
                                /* send data */
                                uart_putc(LOW(temp_word_buffer));
    1ed2:	80 2f       	mov	r24, r16
    1ed4:	c4 de       	rcall	.-632    	; 0x1c5e <uart_putc>
                                uart_putc(HIGH(temp_word_buffer));
    1ed6:	81 2f       	mov	r24, r17
    1ed8:	c2 de       	rcall	.-636    	; 0x1c5e <uart_putc>

                                /* increment address by 2, since it's a byte address */
                                flash_address += 2;
    1eda:	80 91 6a 00 	lds	r24, 0x006A
    1ede:	90 91 6b 00 	lds	r25, 0x006B
    1ee2:	02 96       	adiw	r24, 0x02	; 2
    1ee4:	90 93 6b 00 	sts	0x006B, r25
    1ee8:	80 93 6a 00 	sts	0x006A, r24
                        /* memory type is flash */
                        if (memory_type == 'F')
                        /* {{{ */ {

                            /* read buffer_size words */
                            for (BUF_T i = 0; i < buffer_size; i += 2) {
    1eec:	f2 e0       	ldi	r31, 0x02	; 2
    1eee:	ff 0e       	add	r15, r31
    1ef0:	fe 14       	cp	r15, r14
    1ef2:	48 f3       	brcs	.-46     	; 0x1ec6 <main+0x24c>
    1ef4:	f4 ce       	rjmp	.-536    	; 0x1cde <main+0x64>
                                flash_address += 2;
                            }

                        } /* }}} */
                        /* if memory type is eeprom */
                        else if (memory_type == 'E')
    1ef6:	85 34       	cpi	r24, 0x45	; 69
    1ef8:	a9 f4       	brne	.+42     	; 0x1f24 <main+0x2aa>
    1efa:	10 e0       	ldi	r17, 0x00	; 0
    1efc:	10 c0       	rjmp	.+32     	; 0x1f1e <main+0x2a4>

                            for (uint8_t i = 0; i < buffer_size; i += 1) {
                                uint8_t temp_buffer;

                                /* read and send byte */
                                temp_buffer = eeprom_read_byte((uint8_t *)eeprom_address);
    1efe:	80 91 68 00 	lds	r24, 0x0068
    1f02:	90 91 69 00 	lds	r25, 0x0069
    1f06:	15 d0       	rcall	.+42     	; 0x1f32 <__eerd_byte_m8>
                                uart_putc(temp_buffer);
    1f08:	aa de       	rcall	.-684    	; 0x1c5e <uart_putc>

                                eeprom_address++;
    1f0a:	80 91 68 00 	lds	r24, 0x0068
    1f0e:	90 91 69 00 	lds	r25, 0x0069
    1f12:	01 96       	adiw	r24, 0x01	; 1
    1f14:	90 93 69 00 	sts	0x0069, r25
    1f18:	80 93 68 00 	sts	0x0068, r24
                        } /* }}} */
                        /* if memory type is eeprom */
                        else if (memory_type == 'E')
                        /* {{{ */ {

                            for (uint8_t i = 0; i < buffer_size; i += 1) {
    1f1c:	1f 5f       	subi	r17, 0xFF	; 255
    1f1e:	1e 15       	cp	r17, r14
    1f20:	70 f3       	brcs	.-36     	; 0x1efe <main+0x284>
    1f22:	dd ce       	rjmp	.-582    	; 0x1cde <main+0x64>
            /* 'F': read fuse bits -- NOT IMPLEMENTED */
            /* 'N': read high fuse bits -- NOT IMPLEMENTED */
            /* 'Q': read extended fuse bits -- NOT IMPLEMENTED */ /* }}} */

            default:    /* default: respond with '?' */
                        uart_putc('?');
    1f24:	8f e3       	ldi	r24, 0x3F	; 63
    1f26:	9b de       	rcall	.-714    	; 0x1c5e <uart_putc>
    1f28:	da ce       	rjmp	.-588    	; 0x1cde <main+0x64>
            wait_for_char() ||
#   endif
            0)) {
				
#       if SEND_BOOT_MESSAGE
        uart_putc('a');
    1f2a:	81 e6       	ldi	r24, 0x61	; 97
    1f2c:	98 de       	rcall	.-720    	; 0x1c5e <uart_putc>
#       endif

        start_application();
    1f2e:	9f de       	rcall	.-706    	; 0x1c6e <start_application>
    1f30:	cc ce       	rjmp	.-616    	; 0x1cca <main+0x50>

00001f32 <__eerd_byte_m8>:
    1f32:	e1 99       	sbic	0x1c, 1	; 28
    1f34:	fe cf       	rjmp	.-4      	; 0x1f32 <__eerd_byte_m8>
    1f36:	9f bb       	out	0x1f, r25	; 31
    1f38:	8e bb       	out	0x1e, r24	; 30
    1f3a:	e0 9a       	sbi	0x1c, 0	; 28
    1f3c:	99 27       	eor	r25, r25
    1f3e:	8d b3       	in	r24, 0x1d	; 29
    1f40:	08 95       	ret

00001f42 <__eewr_byte_m8>:
    1f42:	26 2f       	mov	r18, r22

00001f44 <__eewr_r18_m8>:
    1f44:	e1 99       	sbic	0x1c, 1	; 28
    1f46:	fe cf       	rjmp	.-4      	; 0x1f44 <__eewr_r18_m8>
    1f48:	9f bb       	out	0x1f, r25	; 31
    1f4a:	8e bb       	out	0x1e, r24	; 30
    1f4c:	2d bb       	out	0x1d, r18	; 29
    1f4e:	0f b6       	in	r0, 0x3f	; 63
    1f50:	f8 94       	cli
    1f52:	e2 9a       	sbi	0x1c, 2	; 28
    1f54:	e1 9a       	sbi	0x1c, 1	; 28
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	01 96       	adiw	r24, 0x01	; 1
    1f5a:	08 95       	ret

00001f5c <_exit>:
    1f5c:	f8 94       	cli

00001f5e <__stop_program>:
    1f5e:	ff cf       	rjmp	.-2      	; 0x1f5e <__stop_program>
